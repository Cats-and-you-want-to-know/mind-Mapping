### 1. 浏览器的主要组成部分是什么？
1. **用户界面**: 包括地址栏、前进/后退按钮、书签菜单等。
2. **浏览器引擎**: 在用户界面与呈现引擎之间传送指令。
3. **呈现引擎**: 负责显示请求的内容。如果请求的内容是HTML，它就负责解析HTML和CSS内容，并将解析后的内容显示在屏幕上。
4. **网络**: 用于网络调用，比如HTTP请求。
5. **用户界面引擎**: 用于绘制基本的窗口小部件，比如组合框和窗口。
6. **JS解释器**: 用于解析和执行JS代码。
7. **数据存储**: 这是持久层，浏览器需要在硬盘上保存各种数据，例如cookie。HTML5定义了"网络数据库",这是一个完整（但是轻便）的浏览器内数据库。

### 2. 为什么JS是单线程的，与异步冲突吗？
JS的单线程是指一个浏览器进程中只有一个JS的执行线程，同一时刻内只会有一段代码在执行。

举个例子，假设JS支持多线程操作的话，JS可以操作DOM，那么一个线程正在删除DOM，另外一个线程就在获取DOM数据，这样子明显不合理。

异步机制是浏览器的两个或以上常驻线程共同完成的，举个例子，比如异步请求由两个常驻线程，JS执行线程和事件触发线程共同完成的。
- JS执行线程发起异步请求（浏览器会开启一个HTTP请求线程来执行请求，这时JS的任务完成，继续执行线程队列中剩下任务）
- 然后在未来的某一时刻事件触发线程监视到之前的发起的HTTP请求已完成，它就会把完成事件插入到JS执行队列的尾部等待JS处理。

比如定时器触发`setTimeout`和`setinterval`，是由**浏览器的定时器线程**执行的定时器计数，然后在定时时间把处理函数的执行请求插入到JS执行队列的尾端。

所以JS单线程与异步更多是浏览器行为，之间不冲突。

### 3. CSS加载会造成阻塞吗？
- CSS不会阻塞DOM解析，但是会阻塞DOM渲染。
- CSS会阻塞JS执行，并不会阻塞JS文件下载。

先讲一讲CSSOM作用
- 提供给JS操作样式表的能力
- 为布局树的合成提供基础的样式信息
- 这个CSSOM体现在DOM中就是`document.styleSheets`

DOM和CSSOM通常是并行构建的，所以**CSS加载不会阻塞DOM的解析**

因为**Render Tree**依赖DOM和CSSOM Tree的，所以它必须等待两者都加载完毕后，完成响应的构建才开始渲染，因此**CSS加载会阻塞DOM渲染**

**有时候JS需要等到CSS的下载，这是为什么呢？**

如果脚本的内容是获取元素的样式、宽高等CSS控制的属性，浏览器是需要计算的，也就是依赖于CSS。浏览器也无法感知脚本内容到底是什么，为了避免样式获取，因此只好等前面所有的样式下载完后，再执行JS。JS文件下载和CSS文件下载是并行的，有时候CSS文件很大，所以JS需要等待。

因此，样式表会在后面的JS执行前先加载执行完毕，所以**CSS会阻塞后面JS的执行**

### 4. 为什么JS会阻塞页面加载？
这也是说什么JS文件放在最下面的原因

由于JS是可操纵DOM和CSS样式的，如果在修改这些元素属性同时渲染界面（即JS线程和GUI线程同时运行），那么渲染线程前后获得的元素数据就可能不一致了。

因此为了防止渲染出现不可预期的结果，浏览器设置**GUI渲染线程与JS引擎为互斥**的关系。

当JS引擎执行时，GUI渲染线程就会被挂起，GUI更新会被保存到一个队列中等到引擎线程空闲时立即被执行。

当浏览器在执行JS程序的时候，GUI渲染线程就被保存在一个队列中，知道JS程序执行完成，才会接着执行。

因此如果JS执行时间过长吗，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞的感觉。

**如果JS文件中没有操作DOM相关的代码，就可以将该JS脚本设置成异步加载，通过async或defer来标记代码**

### 5. defer和async的区别? 
- 两者都是异步加载外部JS文件，不会阻塞DOM解析
- async是在外部JS加载完成后，浏览器空闲时，Load事件触发前执行，标记为async的脚本并不保证按照制定它们的先后顺序执行，该属性对于内联脚本无作用（即没有src属性的脚本）
- defer是在JS加载完成后，整个文档解析完成后，触发`DOMContentLoaded`事件前执行，如果缺少src属性，该属性不应被使用。

### 6. DOMContentLoaded与load的区别?
- `DOMContentLoaded`事件触发时: 仅当DOM解析完成后，不包括样式表，图片等资源。
- `load`事件触发时: 页面上所有的DOM，样式表，脚本，图片等资源已经加载完成。

> 带async的脚本一定会在load事件执行执行，可能会在`DOMContentLoaded`之前或之后执行。
- 情况1: HTML还没有解析完的时候，async脚本已经加载完了，那么HTML停止解析，去执行脚本，脚本执行完毕后触发`DOMContentLoaded`事件
- 情况2: HTML解析完之后，async脚本才加载完，然后再执行脚本，那么在HTML解析完毕，async脚本还没有加载完的时候触发`DOMContentLoaded`事件

> script标签中包含defer，那么这一块将不会影响HTML文档的解析，而是等待HTML解析完成后才会执行。而`DOMContentLoaded`只有在defer脚本执行结束后才会被触发。

- 情况1: HTML还没有解析完成时，defer脚本已经加载完毕，那么defer脚本将等待HTML解析后再执行。defer脚本执行完毕后触发`DOMContentLoaded`事件。
- 情况2: HTML解析完成时，defer脚本还没有加载完毕，那么defer脚本继续加载，加载完成后直接执行，执行完毕后触发`DOMContentLoaded`事件。

### 7. 函数节流
节流的意思是让函数有节制地执行，而不是毫无节制地触发一次就执行一次，在一段时间内，只执行一次。如果在这个单位时间内触发多次函数，只有一次生效。

常见应用场景: 
1. 监听滚动事件，比如是否滑到底部自动加载更多。
2. 鼠标的点击事件，比如`mousedown`只触发一次。

### 8. 函数防抖
在事件被触发n秒后再执行回调，如果在这n秒内又被触发，则重新计时。

核心思想: 每次事件触发都会删除原有定时器，建立新的定时器。通俗意思就是反复触发函数，只认最后一次，从最后一次开始计时。

适合应用场景: 
1. search搜索: 用户不断输入值，用防抖来节约AJAX请求，也就是输入框事件。
2. window触发resize时，不断调整浏览器窗口大小会不断地触发这个事件，用防抖来让其只触发一次。

### 9. Cookie的作用
1. 会话状态管理(如用户登录状态、购物车、游戏分数或其他需要记录的信息)
2. 个性化设置(如用户自定义设置、主题等)
3. 浏览器行为跟踪(如跟踪分析用户行为等)

### 10. Cookie的缺点
1. 容量缺陷: Cookie的体积上限只有**4KB**，只能存储少量信息。
2. 降低性能: Cookie紧跟着域名，不管域名下的某个地址是否需要这个Cookie,请求都会带上这个Cookie,请求数量增加，会造成巨大的浪费。
3. 安全缺陷: Cookie是以纯文本的形式是在浏览器和服务器中传递，很容易被非法用户获取，当HTTPOnly为false时，Cookie信息还可以直接通过JS脚本读取。

### 11. localStorage和sessionStorage
分类 | 生命周期 | 存储容量 | 存储位置 |
---|--- |--- |--- |
cookie | 默认保存在内存中，随浏览器关闭失效(若设置过期时间，到期时间后失效) |4KB |保存在客户端，每次请求时都会带上|
localStorage | 理论上永久有效的，除非主动清除 |4.98MB（不同浏览器情况不同，safari2.49MB）|保存在客户端，不与服务器交互。节省网络流量|
sessionStorage | 仅在当前网页会话下有效，关闭页面或浏览器会被清除 |4.98MB（部分浏览器没有限制）|同上|

**应用场景**:
1. `localStorage`适合持久化缓存数据。
2. `sessionStorage`适合
**应用场景**:一次性临时数据保存，存储本次浏览信息记录，这样子页面关闭的话，就不需要这些记录了。

### 12. 浏览器缓存
#### 1. 强缓存
- Expires(Http1.0)

即过期时间，时间是相对于服务器的时间而言，存在于服务端返回的响应头中，在这个过期时间之前可以直接从缓存里面获取数据，无需再次请求。比如下面这样: 

`Expires:Mon, 29 Jun 2020 11:10:23 GMT`

表示该资源在2020年7月29日11:10:23过期，过期时就会重新向服务器发起请求。这个方式有一个问题:`服务器的时间和浏览器的时间可能并不一致`

- Cache-Control(Http1.1)

这个字段采用的时间是过期时间

`Cache-Control:max-age=6000`

**注意**
1. `Expires`和`Cache-Control`同时存在时，优先考虑`Cache-Control`
2. 当缓存资源失效时，接下来进入协商缓存。

#### 2. 协商缓存
强缓存失效后，浏览器在请求头中携带响应的`缓存Tag`来向服务器发送请求，服务器根据对应的tag,来决定是否使用缓存。缓存分为两种，`Last-Modified`和`ETag`。
1. Last-Modified

这个字段表示**最后修改时间**，在浏览器第一次给服务器发送请求后，服务器会在响应头加上这个字段。
浏览器接收到后，如果再次请求，会在请求头中携带**if-Modified-Since**字段，这个字段也就是服务器传来的最后修改时间。
服务器拿到请求头中的`if-Modified-Since`的字段后，其实会和这个服务器中**该资源的最后修改时间**对比: 

- 如果请求头中的这个值小于最后修改时间，说明是时候更新了。返回新的资源，跟常规的HTTP请求响应的流程一样。
- 否则返回304，告诉浏览器直接使用缓存。

2. ETag
ETag是服务器根据当前文件的内容，对文件生成唯一的标识，比如MD5算法，只要里面的内容有改动，这个值就会修改，服务器通过把响应头把该字段给浏览器。浏览器接受到ETag值，会在下次请求的时候，将这个值作为**If-None-Match**这个字段的内容，发给服务器。

服务器接收到**if-None-Match**后，会跟服务器上该资源的**ETag**进行对比: 

- 如果两者一样，返回304,告诉浏览器直接使用缓存
- 如果不一样，说明内容更新了，返回新的资源，跟常规的HTTP请求响应的流程一样
